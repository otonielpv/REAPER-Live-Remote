<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Reaper Live Remote - Song</title>
  <link rel="stylesheet" href="css/app.css">
</head>
<body>
  <div class="app-container">
    <!-- Header -->
    <header class="app-header">
      <button id="btn-back" class="icon-btn" data-i18n="back" data-i18n-title="back" title="Back">
        ‚Üê 
      </button>
      <h1 id="song-title" data-i18n="song">Song</h1>
      <div class="header-actions">
        <button id="btn-lang-toggle" class="icon-btn" title="Toggle Language">
          EN
        </button>
        <button id="btn-refresh" class="icon-btn" data-i18n-title="reload" title="Reload">
          üîÑ
        </button>
      </div>
    </header>

    <!-- Modo de salto -->
    <div id="jump-mode-container" class="jump-mode-container">
      <!-- Se llenar√° con JavaScript -->
    </div>

    <!-- Configuraci√≥n de compases -->
    <div id="bar-count-container" class="bar-count-container">
      <!-- Se llenar√° con JavaScript -->
    </div>

    <!-- Transporte -->
    <div id="transport-container" class="transport-container">
      <!-- Se llenar√° con JavaScript -->
    </div>

    <!-- Tabs -->
    <nav class="tabs">
      <button class="tab-btn active" data-tab="sections" data-i18n="sections">Sections</button>
      <button class="tab-btn" data-tab="mixer" data-i18n="mix">Mix</button>
    </nav>

    <!-- Main Content -->
    <main class="app-main">
      <!-- Tab: Secciones -->
      <div id="tab-sections" class="tab-content active">
        <div id="sections-list" class="sections-list">
          <!-- Se llenar√° con JavaScript -->
        </div>
      </div>

      <!-- Tab: Mezcla -->
      <div id="tab-mixer" class="tab-content">
        <div id="mixer-faders" class="mixer-faders">
          <!-- Se llenar√° con JavaScript -->
        </div>
      </div>
    </main>

    <!-- Footer -->
    <footer class="app-footer">
      <div class="connection-status">
        <span id="status-indicator" class="status-indicator"></span>
        <span id="status-text" data-i18n="connecting">Connecting...</span>
      </div>
    </footer>
  </div>

  <!-- Scripts -->
  <script type="module">
    import * as api from './js/api.js';
    import * as state from './js/state.js';
    import * as ui from './js/ui.js';
    import * as utils from './js/utils.js';
    import * as i18n from './js/i18n.js';

    // Initialize i18n
    await i18n.initI18n();

    // Elementos del DOM
    const songTitle = document.getElementById('song-title');
    const btnBack = document.getElementById('btn-back');
    const btnRefresh = document.getElementById('btn-refresh');
    const btnLangToggle = document.getElementById('btn-lang-toggle');
    const jumpModeContainer = document.getElementById('jump-mode-container');
    const barCountContainer = document.getElementById('bar-count-container');
    const transportContainer = document.getElementById('transport-container');
    const sectionsListContainer = document.getElementById('sections-list');
    const mixerFadersContainer = document.getElementById('mixer-faders');
    const statusIndicator = document.getElementById('status-indicator');
    const statusText = document.getElementById('status-text');

    // Obtener songId de la URL
    const songId = parseInt(utils.getQueryParam('songId'));
    
    if (!songId) {
      window.location.href = 'index.html';
    }

    /**
     * Cargar datos de la canci√≥n
     */
    async function loadSongData() {
      try {
        ui.showLoading(sectionsListContainer);
        ui.showLoading(mixerFadersContainer);
        
        // Cargar marcadores, regiones y pistas en paralelo
        const [markers, regions, tracks] = await Promise.all([
          api.getMarkers(),
          api.getRegions(),
          api.getTracks()
        ]);
        
        // Actualizar estado
        state.setMarkers(markers);
        state.setRegions(regions);
        state.setTracks(tracks);
        state.setCurrentSong(songId);
        
        // Encontrar la canci√≥n (puede ser marker o region seg√∫n modo)
        const song = state.getCurrentSong();
        if (!song) {
          throw new Error(i18n.t('song_not_found'));
        }
        
        // Actualizar t√≠tulo
        songTitle.textContent = song.name;
        
        // Obtener secciones de esta canci√≥n (puede ser regiones o marcadores seg√∫n modo)
        const songSections = state.getSectionsForSong(songId);
        
        // Renderizar UI
        renderUI(songSections, tracks);
        
        // Actualizar conexi√≥n
        updateConnectionStatus(true);
        
        console.log(`‚úÖ Canci√≥n cargada: ${song.name} (${songSections.length} secciones, ${tracks.length} pistas)`);
        
      } catch (error) {
        console.error('Error cargando canci√≥n:', error);
        ui.showError(i18n.t('loading_song_data'));
        updateConnectionStatus(false);
      }
    }

    /**
     * Renderizar toda la UI
     */
    function renderUI(regions, tracks) {
      // Modo de salto
      ui.renderJumpModeToggle(jumpModeContainer, state.state.jumpMode);
      
      // Selector de compases (siempre visible)
      ui.renderMixerOptions(barCountContainer);
      
      // Transporte
      ui.renderTransport(transportContainer);
      
      // Secciones (ya no necesita jumpMode, lo obtiene internamente)
      ui.renderSections(sectionsListContainer, regions);
      
      // Mezcla
      ui.renderMixerFaders(mixerFadersContainer, tracks);
    }

    /**
     * Actualizar indicador de estado de conexi√≥n
     */
    function updateConnectionStatus(connected) {
      if (connected) {
        statusIndicator.className = 'status-indicator connected';
        statusText.textContent = i18n.t('connected');
      } else {
        statusIndicator.className = 'status-indicator disconnected';
        statusText.textContent = i18n.t('disconnected');
      }
    }

    /**
     * Cambiar de tab
     */
    function switchTab(tabName) {
      // Actualizar botones
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('data-tab') === tabName);
      });
      
      // Actualizar contenido
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.toggle('active', content.id === `tab-${tabName}`);
      });
      
      // Controlar polling del mezclador
      if (tabName === 'mixer') {
        // Iniciar polling cuando entramos a la pesta√±a de mezcla
        if (!api.isPolling()) {
          console.log('üéöÔ∏è ' + i18n.t('starting_mixer_sync'));
          api.startPolling({
            onTracksUpdate: (tracks) => {
              // Actualizar estado
              state.setTracks(tracks);
              // Actualizar UI sin recrear faders
              ui.updateMixerFaders(tracks);
            }
          }, 500); // Cada 500ms
        }
      } else {
        // Detener polling cuando salimos de la pesta√±a de mezcla
        if (api.isPolling()) {
          console.log('üéöÔ∏è ' + i18n.t('stopping_mixer_sync'));
          api.stopPolling();
        }
      }
    }

    /**
     * Limpiar recursos antes de salir de la p√°gina
     */
    function cleanup() {
      // Detener polling de mixer
      if (api.isPolling()) {
        console.log('üßπ Limpiando polling de mixer');
        api.stopPolling();
      }
      console.log('üßπ Limpiando recursos de song.html');
    }

    /**
     * Event listeners
     */
    btnBack.addEventListener('click', () => {
      cleanup();
      window.history.back();
    });

    btnRefresh.addEventListener('click', () => {
      loadSongData();
    });

    btnLangToggle.addEventListener('click', async () => {
      const currentLang = i18n.getCurrentLang();
      const newLang = currentLang === 'es' ? 'en' : 'es';
      
      // Callback to re-render components after language change
      const reRenderComponents = () => {
        const songSections = state.getSectionsForSong(songId);
        const tracks = state.state.tracks;
        
        // Re-render the dynamic components that use i18n
        ui.renderJumpModeToggle(jumpModeContainer, state.state.jumpMode);
        ui.renderMixerOptions(barCountContainer);
        ui.renderTransport(transportContainer);
      };
      
      await i18n.setLanguage(newLang, reRenderComponents);
    });

    // Tabs
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const tabName = btn.getAttribute('data-tab');
        switchTab(tabName);
      });
    });
    
    // Detener polling cuando se cierra/oculta la p√°gina
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        if (api.isPolling()) {
          console.log('üëã ' + i18n.t('page_hidden_stopping'));
          api.stopPolling();
        }
      } else {
        // Si volvemos a la p√°gina y estamos en la pesta√±a mixer, reiniciar polling
        const activeMixer = document.querySelector('.tab-content#tab-mixer.active');
        if (activeMixer && !api.isPolling()) {
          console.log('üëÅÔ∏è ' + i18n.t('page_visible_restarting'));
          api.startPolling({
            onTracksUpdate: (tracks) => {
              state.setTracks(tracks);
              ui.updateMixerFaders(tracks);
            }
          }, 500);
        }
      }
    });

    // Cargar al iniciar
    loadSongData();
    
    // Variable para rastrear la secci√≥n activa anterior
    let previousSectionId = null;
    
    // Polling de estado (cada 500ms)
    let statePollingInterval = setInterval(async () => {
      if (document.visibilityState === 'visible') {
        try {
          const playState = await api.getPlayState();
          state.updatePlayState(playState.isPlaying, playState.pos);
          
          // Detectar en qu√© secci√≥n (marcador) estamos bas√°ndonos en la posici√≥n
          const currentPos = playState.pos;
          
          // Obtener secciones de la canci√≥n actual
          const songSections = state.getSectionsForSong(songId);
          
          // Buscar marcador m√°s cercano que no hayamos pasado
          let currentSection = null;
          for (let i = songSections.length - 1; i >= 0; i--) {
            if (currentPos >= songSections[i].pos) {
              currentSection = songSections[i];
              break;
            }
          }
          
          // Si cambiamos de secci√≥n, actualizar UI
          if (currentSection) {
            if (currentSection.id !== previousSectionId) {
              console.log(`üìç ${i18n.t('section_change_detected')}: "${currentSection.name}" (${currentSection.id})`);
              previousSectionId = currentSection.id;
              state.setCurrentRegion(currentSection.id);
              
              // Actualizar resaltado visual usando la funci√≥n exportada de ui.js
              ui.highlightActiveSection(currentSection.id);
            }
          } else if (previousSectionId !== null) {
            // Ya no estamos en ninguna secci√≥n
            console.log('üìç ' + i18n.t('outside_sections'));
            previousSectionId = null;
            ui.highlightActiveSection(null);
          }
          
        } catch (error) {
          // Silencioso en polling
        }
      }
    }, 500);
    
    // Limpiar cuando se descarga la p√°gina
    window.addEventListener('beforeunload', cleanup);
    window.addEventListener('pagehide', cleanup);
    
  </script>
</body>
</html>
